package controller;

import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.client.util.Base64;
import com.google.api.client.util.store.FileDataStoreFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.Draft;
import com.google.common.hash.Hashing;
import model.game.User;
import model.game.ValidationRegex;
import model.menu.MenuName;
import view.message.MenuMessage;
import com.google.api.services.gmail.model.Message;

import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.sql.DataSource;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.Date;
import java.util.Properties;
import java.util.Set;
import java.util.regex.Matcher;

public class RegisterMenu extends Menu {
    private static RegisterMenu instance;
    private String validationCode; //this is for email validation.

    private RegisterMenu() {
        super.setMenuName(MenuName.RegisterMenu);
    }

    public static RegisterMenu getInstance() {
        if (instance == null)
            instance = new RegisterMenu();
        return instance;
    }

    public String registerValidate(String username, String nickname, String email, String password) {
        return usernameValidation(username) +
                nicknameValidation(nickname) +
                emailValidation(email) +
                passwordValidation(password);
    }

    public String register(String username, String nickname, String email, String password, String confirmPassword,String question, String answer) {
        String result = "";
        if (!password.equals(confirmPassword))
            result = MenuMessage.PASSWORD_IS_NOT_THE_SAME.message();
        result +=  registerValidate(username, nickname, email, password);
        if (result.isEmpty())
            new User(username, nickname, email, password, question, answer);
        return result;
    }

    public String usernameValidation(String username) {
        Matcher matcher = ValidationRegex.Username.getMatcher(username);
        StringBuilder result = new StringBuilder();
        if (!matcher.find())
            result.append(MenuMessage.INVALID_USERNAME.message()).append("\n");
        return result.toString();
    }

    public String nicknameValidation(String nickname) {
        Matcher matcher = ValidationRegex.Nickname.getMatcher(nickname);
        StringBuilder result = new StringBuilder();
        if (!matcher.find())
            result.append(MenuMessage.INVALID_NICKNAME.message()).append("\n");
        return result.toString();
    }

    public String emailValidation(String email) {
        Matcher matcher = ValidationRegex.Email.getMatcher(email);
        StringBuilder result = new StringBuilder();
        if (!matcher.find())
            result.append(MenuMessage.INVALID_EMAIL.message()).append("\n");
        return result.toString();
    }

    public String passwordValidation(String password) {
        Matcher matcher = ValidationRegex.Password.getMatcher(password);
        StringBuilder result = new StringBuilder();
        if (!matcher.find()) {
            result.append(MenuMessage.WEAK_PASSWORD.message()).append("\n");
            //This part is to suggest a password that is generated by sha256 hashing algorithm.
            String suggestedPassword = Hashing.sha256().hashString(password, StandardCharsets.UTF_8).toString();
            result.append(suggestedPassword).append("\n");
        }
        return result.toString();
    }


    public static void sendEmailWithAuthorization(String toEmail, String username) {
        //set message headers
        try {
            final String fromEmail = "hgp.master@gmail.com"; //requires valid gmail id
            final String password = "h7491685230"; // correct password for gmail id// can be any email id

            Properties props = new Properties();
            props.put("mail.smtp.host", "smtp.gmail.com"); //SMTP Host
            props.put("mail.smtp.port", "587"); //TLS Port
            props.put("mail.smtp.auth", "true"); //enable authentication
            props.put("mail.smtp.starttls.enable", "true"); //enable STARTTLS
            //create Authenticator object to pass in Session.getInstance argument
            Authenticator auth = new Authenticator() {
                //override the getPasswordAuthentication method
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(fromEmail, password);
                }
            };
            Session session = Session.getInstance(props, auth);
            String subject = "Gwent authorization to user :" + username;
            String code = Hashing.sha256().hashString(username, StandardCharsets.UTF_8).toString();
            String content = "YOUR AUTHORIZATION CODE: " + code;
            sendEmail(session, toEmail, subject, content);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void sendEmail(Session session, String toEmail, String subject, String body){
        try
        {
            MimeMessage msg = new MimeMessage(session);
            //set message headers
            msg.addHeader("Content-type", "text/HTML; charset=UTF-8");
            msg.addHeader("format", "flowed");
            msg.addHeader("Content-Transfer-Encoding", "8bit");

            msg.setFrom(new InternetAddress("no_reply@example.com", "NoReply-JD"));

            msg.setReplyTo(InternetAddress.parse("no_reply@example.com", false));

            msg.setSubject(subject, "UTF-8");

            msg.setText(body, "UTF-8");

            msg.setSentDate(new Date());

            msg.setRecipients(javax.mail.Message.RecipientType.TO, InternetAddress.parse(toEmail, false));
            System.out.println("Message is ready");
            Transport.send(msg);

            System.out.println("EMail Sent Successfully!!");
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static class GMailer {
        private static Credential getCredentials(final NetHttpTransport httpTransport, GsonFactory jsonFactory)
                throws IOException {
            GoogleClientSecrets clientSecrets =
                    GoogleClientSecrets.load(jsonFactory
                            , new InputStreamReader(GMailer.class.getResourceAsStream("/...json")));

            // Build flow and trigger user authorization request.
            GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(
                    httpTransport, jsonFactory, clientSecrets, Set.of(GmailScopes.GMAIL_SEND))
                    .setDataStoreFactory(new FileDataStoreFactory(Paths.get("tokens").toFile()))
                    .setAccessType("offline")
                    .build();
            LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
            //returns an authorized Credential object.
            return new AuthorizationCodeInstalledApp(flow, receiver).authorize("user");
        }

        public void sendMail(String subject, String msg) throws Exception {
            final NetHttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport();
            GsonFactory jsonFactory = GsonFactory.getDefaultInstance();
            Gmail service = new Gmail.Builder(httpTransport, jsonFactory, getCredentials(httpTransport, jsonFactory))
                    .setApplicationName("GWENT authorization")
                    .build();

            // Encode as MIME message
            Properties props = new Properties();
            Session session = Session.getDefaultInstance(props, null);
            MimeMessage email = new MimeMessage(session);
            email.setFrom(new InternetAddress("hgp.master@gmail.com"));
            email.addRecipient(javax.mail.Message.RecipientType.TO,
                    new InternetAddress("safariamirparsa@gmail.com"));
            email.setSubject(subject);
            email.setText(msg);
            // Encode and wrap the MIME message into a gmail message
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            email.writeTo(buffer);
            byte[] rawMessageBytes = buffer.toByteArray();
            String encodedEmail = Base64.encodeBase64URLSafeString(rawMessageBytes);
            com.google.api.services.gmail.model.Message message = new Message();
            message.setRaw(encodedEmail);

            try {
                // Create the draft message
                Draft draft = new Draft();
                draft.setMessage(message);
                draft = service.users().drafts().create("me", draft).execute();
                System.out.println("Draft id: " + draft.getId());
                System.out.println(draft.toPrettyString());
            } catch (GoogleJsonResponseException e) {
                // TODO(developer) - handle error appropriately
                GoogleJsonError error = e.getDetails();
                if (error.getCode() == 403) {
                    System.err.println("Unable to create draft: " + e.getDetails());
                } else {
                    throw e;
                }
            }
        }

        public static void main(String[] args) throws Exception {
            new GMailer().sendMail("subject", "msg");
        }
    }
}
